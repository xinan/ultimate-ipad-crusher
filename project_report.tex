\documentclass[12pt,a4paper,oneside]{report}

\usepackage{enumitem}
\usepackage{setspace}
\usepackage[none]{hyphenat}
\usepackage{algorithm} 
\usepackage{algorithmic}
\usepackage{amsmath}

\newcommand{\INDSTATE}[1][1]{\STATE\hspace{#1\algorithmicindent}}

\begin{document}

%===============================================================================
% Start of Cover Page
%===============================================================================
\title{\Huge\textbf{The iPad Crusher \vfill
	\large Project Report \\ \bigskip
	for \\ \bigskip
	CS2309 CS Research Methodology \\ \bigskip
	\large AY15/16 Sem 1 \vfill}
	}
\author{
	Department of Computer Science \\\\
	School of Computing \\\\
	National University of Singapore}
%\date{}

\maketitle
%===============================================================================
% End of Cover Page
%===============================================================================

\pagenumbering{roman}

%===============================================================================
% Start of Title Page
%===============================================================================
\begin{titlepage}
\addcontentsline{toc}{chapter}{Title Page}
\thispagestyle{plain}
\begin{center}
\textbf{\Huge The iPad Crusher \vfill
	\large Project Report \\ \bigskip
	for \\ \bigskip
	CS2309 CS Research Methodology \\ \bigskip
	AY15/16 Sem 1} \vfill \vfill
\large Members: \\ \bigskip
\begin{minipage}[t]{0.3\textwidth}
\begin{flushleft}
Lai Hoang Dung \\ \bigskip
Lim Kiat \\ \bigskip
Liu Xinan \\ \bigskip
Tran Tien Dat
\end{flushleft}
\end{minipage}
\begin{minipage}[t]{0.3\textwidth}
\begin{flushright}
A0131125Y \\ \bigskip
A0124099B \\ \bigskip
A0130195M \\ \bigskip
A0131140E
\end{flushright}
\end{minipage} \vfill
Supervisor: \\ \bigskip
Prof. Sim Khe Chai
\end{center}
\end{titlepage}
%===============================================================================
% End of Title Page
%===============================================================================

%===============================================================================
% Start of Abstract
%===============================================================================
\begin{abstract}
\setcounter{page}{2}
\thispagestyle{plain}
\onehalfspacing
\addcontentsline{toc}{chapter}{Abstract}
In this project, we were asked to design the game logic for ``iPad Crusher'', an iOS game that Prof. Sim is developing as an adaptation to the Egg Dropping Problem. Given a certain number of iPads and strength levels, the player is asked to find the lowest strength level that would break an iPad. Similar to the Egg Dropping Puzzle, the goal of the game is to find the best strategy so that it involves the fewest number of crushing in the worst-case scenario. \\\\
In this report we present two approaches in designing the game logic, the first is the original solution that we came up with, which is to generate the cost table and make the game decisions based on the costs. The second approach is one that Prof. Sim briefly mentioned, which decides based on the optimum level stored in a table. We would discuss the advantages and disadvantages of each of the two approaches, as well as different implementations of them. Lastly we would discuss some interesting extension of the problem such as adding an extra cost for breaking an iPad, and a variant of it with unlimited number of iPads, etc. In the end we conclude that for the original game logic, the cost table approach would be the better choice, whereas for some extensions, the decision tree approach would be better.

\subsubsection*{Subject Descriptors:\\}
\begin{description}[labelindent=1cm]
	\item[I.2.8] Dynamic Programming
	\item[K.8.0] Games
	\item[G.2.1] Combinatorics
\end{description}

\subsubsection{Keywords:}
\begin{description}[labelindent=1cm]
	\item Game Logic, Egg Dropping, Dynamic Programming, Combinatorics
\end{description}

\end{abstract}
%===============================================================================
% End of Abstract
%===============================================================================

%===============================================================================
% Start of Acknowledgements
%===============================================================================
\renewcommand{\abstractname}{Acknowledgements}
\begin{abstract}
\setcounter{page}{3}
\thispagestyle{plain}
\onehalfspacing
\addcontentsline{toc}{chapter}{Acknowledgements}
We could like to thank Prof. Sim Khe Chai for the patience and guidance along the semester. Without Prof. Sim, we would not have gone this far. I don't know what to write here you guys please fill in. \\\\
(TODO)
\end{abstract}
%===============================================================================
% End of Acknowledgements
%===============================================================================

\onehalfspacing
\tableofcontents
\thispagestyle{empty}
\addtocontents{toc}{\protect\thispagestyle{empty}}
\pagenumbering{arabic}

%===============================================================================
% Start of Chapter 1
%===============================================================================
\chapter{Introduction}
\setcounter{page}{1}
\section{About the project}
The egg dropping puzzle is a well known one and an example most often used to illustrate dynamic programming as a concept in computer science. As an adaptation to the egg dropping puzzle, we were tasked to design the game logic for "iPad Crusher", an iOS game that our Prof. is developing. The problem involves $N$ number of iPads available and $L$ strength levels the player can use to crush the iPads. The goal of the game is to find the best strategy so that it involves the fewest number of crushing in the worst-case scenario. In the process leading up to the actual formulation of the game logic, we were guided to first come up with a brute-force approach to finding the best strategy. Thereafter, since the egg dropping puzzle can be solved by using dynamic programming, we have done the same for our problem. With the dynamic programming solution, we were then able to design the game logic, which determines whether the iPad should survive, given the strength level that the user specifies. The game logic is one where it always simulates the worst-case scenario. This means that when a player chooses a strength level he/she wishes to use, the game logic will decide whether to crush the iPad depending on the choice that will result in more tries needed using a best strategy. As a further extension, we explored the case where we have to factor in a fixed iPad cost for each crushing of an iPad, as well as when the iPad cost changes as different numbers of iPads get crushed.

%===============================================================================
% End of Chapter 1
%===============================================================================

%===============================================================================
% Start of Chapter 2
%===============================================================================
\chapter{Existing work}
I put random chapter titles here. Feel free to change. And this is how you cite a source \cite{randomblogpost}.

\section{What does the fox say?}
\subsection{Introduction}
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis quis lacus posuere, tincidunt mauris vitae, bibendum sapien. Suspendisse a eros pretium, pretium libero eget, ornare ante. Donec efficitur gravida pellentesque. Curabitur sit amet pulvinar tortor. In eu risus commodo, elementum tellus ac, commodo mauris. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Integer hendrerit arcu sem, convallis dignissim nisi faucibus at. Praesent ut rutrum libero, sollicitudin blandit dui. Donec mi nisi, cursus quis accumsan et, molestie ut nisi. Sed egestas enim in dolor tincidunt dictum. Sed eu semper sem. Sed elementum augue ac pretium eleifend. Ut massa tortor, rhoncus a mi ac, congue ullamcorper eros. Maecenas imperdiet orci quis dui rhoncus, id rhoncus mi condimentum. Nunc blandit egestas leo, sit amet porttitor mi malesuada nec. Pellentesque id bibendum purus, a porta risus. \\\\

%===============================================================================
% End of Chapter 2
%===============================================================================

%===============================================================================
% Start of Chapter 3
%===============================================================================
\chapter{The cost table approach}
A short brief description of the approach here.

\section{A brute force algorithm}
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis quis lacus posuere, tincidunt mauris vitae, bibendum sapien. Suspendisse a eros pretium, pretium libero eget, ornare ante. Donec efficitur gravida pellentesque. Curabitur sit amet pulvinar tortor. In eu risus commodo, elementum tellus ac, commodo mauris. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Integer hendrerit arcu sem, convallis dignissim nisi faucibus at. Praesent ut rutrum libero, sollicitudin blandit dui. Donec mi nisi, cursus quis accumsan et, molestie ut nisi. Sed egestas enim in dolor tincidunt dictum. Sed eu semper sem. Sed elementum augue ac pretium eleifend. Ut massa tortor, rhoncus a mi ac, congue ullamcorper eros. Maecenas imperdiet orci quis dui rhoncus, id rhoncus mi condimentum. Nunc blandit egestas leo, sit amet porttitor mi malesuada nec. Pellentesque id bibendum purus, a porta risus.

\section{A dynamic programming algorithm}

\section{Pros and Cons}

%===============================================================================
% End of Chapter 3
%===============================================================================

%===============================================================================
% Start of Chapter 4
%===============================================================================
\chapter{The decision tree approach}
A short brief description of the approach here.

\section{A brute force algorithm}
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis quis lacus posuere, tincidunt mauris vitae, bibendum sapien. Suspendisse a eros pretium, pretium libero eget, ornare ante. Donec efficitur gravida pellentesque. Curabitur sit amet pulvinar tortor. In eu risus commodo, elementum tellus ac, commodo mauris. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Integer hendrerit arcu sem, convallis dignissim nisi faucibus at. Praesent ut rutrum libero, sollicitudin blandit dui. Donec mi nisi, cursus quis accumsan et, molestie ut nisi. Sed egestas enim in dolor tincidunt dictum. Sed eu semper sem. Sed elementum augue ac pretium eleifend. Ut massa tortor, rhoncus a mi ac, congue ullamcorper eros. Maecenas imperdiet orci quis dui rhoncus, id rhoncus mi condimentum. Nunc blandit egestas leo, sit amet porttitor mi malesuada nec. Pellentesque id bibendum purus, a porta risus.

\section{A dynamic programming algorithm}

\section{Pros and Cons}

%===============================================================================
% End of Chapter 4
%===============================================================================

%===============================================================================
% Start of Chapter 5
%===============================================================================
\chapter{The online combinatorics approach}
Besides the Dynamic Programming approach to this iPad Crushing problem, we also found an interesting alternative approach online using Combinatorics to calculate how many times we need to crush the iPad in the worst case \cite{randomblogpost}. The original author describes it as a solution to the classic Egg Dropping Puzzle. Here, we formulate the solution in terms of our iPad Crushing problem and make some corrections.

\section{Theory}
Before we begin discussing the solution, we need to reiterate our definition of a strategy to solve the iPad Crushing problem. A strategy is a binary decision tree, with each node representing a level of strength that we will use to try crushing the iPad. Following the left branch represents the scenario that the iPad survives the crush, while the right branch represents the scenario when the iPad does not survive the crush. A leaf of the tree represents the the minimum level of strength to crush the iPad that we have found.

The number of crushings we need to do to determine the minimum strength level to crush the iPad is the length of a path from the root node to a leaf. Hence, the number of crushings in the worst case is just the height of the decision tree. The goal of the game is to find a decision tree with minimum height.

Similar to the dynamic programming approach, given the number of levels $L$ and the number of iPads $N$, we will need to find the minimum height $H$ of a decision tree to solve this iPad Crushing Problem. However, we will do this by formulating a slightly different problem. This is quite similar to the proof that all comparison-based sorting algorithms need to make at least $\log n$ comparisons in the worst case. An iPad Crushing problem with $N$ iPads and $L$ strength levels has a decision tree of height $H$. We will find the maximum $L$, given $N$ and $H$.

We will count the number of possible paths in the decision tree of height $H$. The number of paths is equal to the number of  leaves, which is exactly $L+1$, as there are $L+1$ possible values for the minimum strength level to crush the iPad.

In addition, every path from the root node to a leaf can branch to the right (the iPad does not survive) at most $N$ times. Hence each path can be represented by a binary sequence of 1 (left) and 0 (right), with at most $N$ zeros (rights). Since the height of our decision tree is $H$, the length of each path is at most $H$. For a path with length less than $H$, we can append it with ones such that the length of its binary sequence representation is always $H$. This is a one-to-one transformation because no path's binary sequence can be contained in another. Hence we have a bijection between the set of possible paths and the set of binary sequence of length $H$ with at most $N$ zeros. There are ${H \choose k}$ binary sequences of length $H$ with $k$ zeros. Therefore, the maximum number of paths in a decision tree of height $H$ is $\sum_{k=0}^{N} {H \choose k}$.

Combine the previous two paragraphs, we arrive at the inequality: \[\sum_{k=0}^{N} {H \choose k} \geq L+1\]

So back to our original problem, the decision tree for this iPad Crushing problem with $N$ iPads and $L$ strength levels will have the minimum height $H$ such that the above inequality holds.

\section{Algorithm}
Based on the theory discussed in the previous section, together with the fact that $H \geq \log L$ since the decision tree is a binary tree, we formulate the following algorithm to calculate the cost in the worst case of the iPad Crushing problem.

\begin{algorithm}
        \caption{Calculate the cost of the iPad Crushing problem with N iPads, L strength levels}
        \begin{algorithmic}[1]
            \REQUIRE N, L
	\STATE $H \leftarrow \lceil \log L\rceil$
	\STATE $sum \leftarrow \sum_{k=0}^{N} {H \choose k}$
	\WHILE {$sum < L+1$}
		\STATE $H \leftarrow H+1$
		\STATE $sum \leftarrow \sum_{k=0}^{N} {H \choose k}$
	\ENDWHILE
	\RETURN $H$
        \end{algorithmic}
\end{algorithm}

\section{Discussion}
We can use the algorithm outlined in the previous section to fill in our $N \times L$ DP table. The running time of this algorithm is dependent on the size of the answer it gets, which grows slower than $O(L)$ - the cost to fill in one entry for the dynamic programming approach\footnote{This is our observation. We do not have enough mathematical knowledge to prove it.}. Hence, we would expect that this algorithm runs faster than the dynamic programming one. Our tests verify this hypothesis. Therefore, an advantage of this approach would be its faster running time.

However, the downside of this approach is that it is harder to tweak to solve modified versions of the iPad Crushing problem. We tried to tweak it to solve the problem when the cost of an iPad is 5. What we have come up with is, to replace each branch to the right with 6 consecutive branchings to the right. Hence the total number of possible paths will be the number of binary sequences of length $H$ such that zeros can only appear in group of 6, and there are at most $N$ groups of 6 zeros. To solve this, we need to consider a group of 6 zeros as one units (one 0), which decreases the length of the sequence to $H - 5 \times number\_of\_groups$. This gives us a more complicated inequality: \[\sum_{k=0}^{N} {H-5k \choose k} \geq L+1\]

We can also modify this approach to solve the problem when there are inifinitely many available iPad for use. Instead of summing until $N$, we can sum until ${H-5k \choose k}$ still makes sense, that is until $\lfloor H/5 \rfloor$. This gives us the inequality: \[\sum_{k=0}^{\lfloor H/5 \rfloor} {H-5k \choose k} \geq L+1\]

%===============================================================================
% End of Chapter 5
%===============================================================================

%===============================================================================
% Start of Chapter 6
%===============================================================================
\chapter{Interesting extensions}
\section{iPad with fixed cost}

What happens if we have to pay a penalty for each crushed iPad. How would it affect the game logic?

To tackle this extension, we realise we can re-use our cost table approach, but modify the comparison step slightly to also include the fixed cost. 

Using the table cost approach, we would calculate the cost of the whole DP table during the game initialisation, and subsequently use the value already calculated in the table cell to make the game decisions

In this extension, we consider two scenarios: The number of iPads is finite or infinite

\subsection{Finite number of iPads}

In the case that there is a finite number of iPads, the DP table will be a 2D array, where the number of rows represent the number of iPads, and the number of columns represents the number of levels

The pseudo code to calculate the DP table is as follows
\begin{algorithm}
        \caption{Calculate the cost table for fixed iPad cost (finite number of iPads)}
        \begin{algorithmic}[1]
            \REQUIRE L, iPadCost
            \STATE Initialise a 1D table DP[L+1], where the value of each cell is INFINITY
            \STATE Let DP[0] be 0
            \STATE Let DP[1] be iPadCost
            \STATE For all other tables cells DP[n] , the value at that cell is equal to min(1 + max(DP[x-1] + iPadCost, DP[L-x])) for $1 \leq x \leq l$
        \end{algorithmic}
\end{algorithm}

We can see that the difference between this and the previous cost table approach without iPad cost is only that the iPad cost is also added to the original cost in each cell

\subsection{Infinite Number of iPads}

In the case that there is an infinite number of iPads, the DP table only needs to be a 1D array. Since the number of iPads is infinite, we no longer need to worry that we might run out of iPads. As such, we only need to consider how the cost will vary by the level. The number of cells in the DP table (or in this case the DP row) hence represents the number of levels

The pseudo code to calculate the DP table is as follows
\begin{algorithm}
        \caption{Calculate the cost table for fixed iPad cost (finite number of iPads)}
        \begin{algorithmic}[1]
            \REQUIRE N, L, iPadCost
            \STATE Initialise a 2D table DP[N+1][L+1], where the value of each cell is INFINITY
            \STATE For all table cells DP[n][l] where l $\leq$ 1, initialise the value of the cell to be l*(1 + iPadCost)
            \STATE For all table cells DP[n][l] where n = 1, initialise the value of the cell to be l + iPadCost
            \STATE For all other tables cells DP[n][l] , the value at that cell is equal to min(1 + max(DP[x-1][n-1] + iPadCost, DP[L-x][n])) for $1 \leq x \leq l$
        \end{algorithmic}
\end{algorithm}

\section{iPad with dynamic cost}
Let's make the problem even more complex. How do we tackle the problem if the cost of the iPad is not fixed, but changing depending on how many iPad has been crushed. 
We can first define a function f, where f(n) denotes the cost of the $n^{th}$ being dropped.
Intuitively, we can see that this problem is very close to the fixed iPad cost problem. We can again use the cost table. approach to pre-calculate the DP cost table. The difference lies in the fact that we also now need to consider how many iPads have been crushed before.
Therefore, to extend the solution for the fixed cost problem to also work in this, we can also store an attribute denoting the number of Ipad crushed. Each cell will then have two attributes, the cost and the number of iPad crushed
The pseudo code to calculate the DP table is as follows
\begin{algorithm}
        \caption{Calculate the cost table for fixed iPad cost}
        \begin{algorithmic}[1]
            \REQUIRE N, L, f
            \STATE Initialise a 2D table $DP[N+1][L+1]$, where each cell has cost $INFINITY$ and numberOfiPadCrushed  $0$
            \STATE For all table cells $DP[n][l]$ where $l \leq 1$, initialise the cost of the cell to be $l*(1 + f(l))$ and numberOfiPadCrushed  to be $l$
            \STATE For all table cells $DP[n][l]$ where $n = 1$, initialise the cost of the cell to be $l+f(1)$ and numberOfiPadCrushed to be $1$
            \STATE For all other tables cell $DP[n][l]$
            \INDSTATE For all $x$ in $1 \leq x \leq l$
            \INDSTATE[2] ipadCostWhenCrushed = f(DP[x-1][n-1].numberOfiPadCrushed +1)
            \INDSTATE[2] If DP[L-x][n].cost >= DP[x-1][n-1].cost + ipadCostWhenCrushed
            \INDSTATE[3] cost = DP[L-x][n].cost + 1
            \INDSTATE[3] numberOfiPadCrushed = DP[L-x][n].numberOfiPadCrushed
            \INDSTATE[2] Otherwise
            \INDSTATE[3] cost = DP[x-1][n-1].cost + ipadCostWhenCrushed
            \INDSTATE[3] numberOfiPadCrushed = DP[x-1][n-1].numberOfiPadCrushed +1
            \INDSTATE[2] If cost $\leq$ DP[n][l]
            \INDSTATE[3] DP[n][l].cost = cost
            \INDSTATE[3] DP[n][l].numberOfiPadCrushed = numberOfiPadCrushed

        \end{algorithmic}
\end{algorithm}
%===============================================================================
% End of Chapter 6
%===============================================================================

%===============================================================================
% Start of Chapter 7
%===============================================================================
\chapter{Conclusion}
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis quis lacus posuere, tincidunt mauris vitae, bibendum sapien. Suspendisse a eros pretium, pretium libero eget, ornare ante. Donec efficitur gravida pellentesque. Curabitur sit amet pulvinar tortor. In eu risus commodo, elementum tellus ac, commodo mauris. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Integer hendrerit arcu sem, convallis dignissim nisi faucibus at. Praesent ut rutrum libero, sollicitudin blandit dui. Donec mi nisi, cursus quis accumsan et, molestie ut nisi. Sed egestas enim in dolor tincidunt dictum. Sed eu semper sem. Sed elementum augue ac pretium eleifend. Ut massa tortor, rhoncus a mi ac, congue ullamcorper eros. Maecenas imperdiet orci quis dui rhoncus, id rhoncus mi condimentum. Nunc blandit egestas leo, sit amet porttitor mi malesuada nec. Pellentesque id bibendum purus, a porta risus.

%===============================================================================
% End of Chapter 7
%===============================================================================

%===============================================================================
% Start of References
%===============================================================================
\renewcommand{\bibname}{References}
\begin{thebibliography}{1} \addcontentsline{toc}{chapter}{References}
	\bibitem{randomblogpost} Egg Drop Puzzle. http://michaelbrundage.com/note/2014/04/26/egg-drop/
\end{thebibliography}

%===============================================================================
% End of References
%===============================================================================
\end{document}
