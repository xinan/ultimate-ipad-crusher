\documentclass[12pt,a4paper,oneside]{report}

\usepackage{enumitem}
\usepackage{setspace}
\usepackage[none]{hyphenat}
\usepackage{algorithm} 
\usepackage{algorithmic}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\graphicspath{ {image/} }

\newcommand{\INDSTATE}[1][1]{\STATE\hspace{#1\algorithmicindent}}

\begin{document}

%===============================================================================
% Start of Cover Page
%===============================================================================
\title{\Huge\textbf{The iPad Crusher \vfill
	\large Project Report \\ \bigskip
	for \\ \bigskip
	CS2309 CS Research Methodology \\ \bigskip
	\large AY15/16 Sem 1 \vfill}
	}
\author{
	Department of Computer Science \\\\
	School of Computing \\\\
	National University of Singapore}
%\date{}

\maketitle
%===============================================================================
% End of Cover Page
%===============================================================================

\pagenumbering{roman}

%===============================================================================
% Start of Title Page
%===============================================================================
\begin{titlepage}
\addcontentsline{toc}{chapter}{Title Page}
\thispagestyle{plain}
\begin{center}
\textbf{\Huge The iPad Crusher \vfill
	\large Project Report \\ \bigskip
	for \\ \bigskip
	CS2309 CS Research Methodology \\ \bigskip
	AY15/16 Sem 1} \vfill \vfill
\large Members: \\ \bigskip
\begin{minipage}[t]{0.3\textwidth}
\begin{flushleft}
Lai Hoang Dung \\ \bigskip
Lim Kiat \\ \bigskip
Liu Xinan \\ \bigskip
Tran Tien Dat
\end{flushleft}
\end{minipage}
\begin{minipage}[t]{0.3\textwidth}
\begin{flushright}
A0131125Y \\ \bigskip
A0124099B \\ \bigskip
A0130195M \\ \bigskip
A0131140E
\end{flushright}
\end{minipage} \vfill
Supervisor: \\ \bigskip
Prof. Sim Khe Chai
\end{center}
\end{titlepage}
%===============================================================================
% End of Title Page
%===============================================================================

%===============================================================================
% Start of Abstract
%===============================================================================
\begin{abstract}
\setcounter{page}{2}
\thispagestyle{plain}
\onehalfspacing
\addcontentsline{toc}{chapter}{Abstract}
In this project, we were asked to design the game logic for ``iPad Crusher'', an iOS game that Prof. Sim is developing as an adaptation to the Egg Dropping Problem. Given a certain number of iPads and strength levels, the player is asked to find the lowest strength level that will break an iPad. Similar to the Egg Dropping Puzzle, the goal of the game is to find the best strategy so that it involves the fewest number of crushing in the worst-case scenario. \\\\
In this report we present three approaches in designing the game logic, the first is the original solution that we came up with, which is to generate the cost table and make the game decisions based on the costs. The second approach is to decide based on the optimum level for each game state stored in a table. The third approach is to use combinatorics. We will discuss the advantages and disadvantages of each of the three approaches, as well as different implementations of them. Lastly, we will also discuss some interesting extensions of the problem such as adding an extra cost for breaking an iPad, etc. To sum up, we conclude that for the game logic, the cost table approach is good because it is fast and simple, whereas the optimum level approach has its advantage too. The combinatorics method is interesting and can be super fast in computing large problems, but it is not as straight forward as the other approaches.

\subsubsection*{Subject Descriptors:\\}
\begin{description}[labelindent=1cm]
	\item[I.2.8] Dynamic Programming
	\item[G.2.1] Combinatorics
\end{description}

\subsubsection{Keywords:}
\begin{description}[labelindent=1cm]
	\item Game Logic, Egg Dropping, Dynamic Programming, Combinatorics
\end{description}

\end{abstract}
%===============================================================================
% End of Abstract
%===============================================================================

%===============================================================================
% Start of Acknowledgements
%===============================================================================
\renewcommand{\abstractname}{Acknowledgements}
\begin{abstract}
\setcounter{page}{3}
\thispagestyle{plain}
\onehalfspacing
\addcontentsline{toc}{chapter}{Acknowledgements}
We would like to thank Prof. Sim Khe Chai for his patience and guidance along the semester. Without Prof. Sim, we would not have gone this far. We would also like to thank our fellow classmates for the interesting discussions we had in our tutorials regarding this project that helped us in thinking deeper about the problem.
\end{abstract}
%===============================================================================
% End of Acknowledgements
%===============================================================================

\onehalfspacing
\tableofcontents
\thispagestyle{empty}
\addtocontents{toc}{\protect\thispagestyle{empty}}
\pagenumbering{arabic}

%===============================================================================
% Start of Chapter 1
%===============================================================================
\chapter{Introduction}
\setcounter{page}{1}
The egg dropping puzzle is a well known one and an example most often used to illustrate dynamic programming as a concept in computer science. As an adaptation to the egg dropping puzzle, we were tasked to design the game logic for ``iPad Crusher'', an iOS game that our Prof. is developing. The problem involves $N$ number of iPads available and $L$ strength levels the player can use to crush the iPads. The goal of the game is to find the best strategy so that it involves the fewest number of crushing in the worst-case scenario. In the process leading up to the actual formulation of the game logic, we were guided to first come up with a brute-force approach to finding the best strategy. Thereafter, since the egg dropping puzzle can be solved using dynamic programming, we have done the same for our problem. With the dynamic programming solution, we were then able to design the game logic, which determines whether the iPad should survive, given the strength level that the player specifies. The game logic is one where it always simulates the worst-case scenario. This means that when a player chooses a strength level he/she wishes to use, the game logic will decide whether to crush the iPad depending on the choice that will result in more tries needed using a best strategy. As further extensions of the problem, we explored the case where we have to factor in a fixed iPad cost for each crushing of an iPad, as well as when the iPad cost changes as different numbers of iPads get crushed.

%===============================================================================
% End of Chapter 1
%===============================================================================

%===============================================================================
% Start of Chapter 2
%===============================================================================
\chapter{Existing work}
Since the egg dropping puzzle is a classic problem, there are quite a number of blog posts about it online, although we did not manage to find any research paper on it.

\section{What did the folks say?}
On the Dynamic Programming Wikipedia page \cite{dpwiki}, there is a small section talking about the original egg dropping puzzle. It provides a way to solve the original egg dropping puzzle using dynamic programming, which is also the solution that most of the web posts about this problem give. Similarly, we will be making use of dynamic programming in one of our approaches as well. \\\\
In one of the web posts, we found a very interesting way of solving the original egg dropping problem, by mapping the problem into a combinatorics problem and do some counting. We will discuss about this in one of the later chapters. \\\\
Besides this, Prof. Sim has also shared with us his approach of designing the game logic, which is different from the approach that we have in mind. We will discuss about how we can extend our approach with ideas from Prof. Sim's approach. 

%===============================================================================
% End of Chapter 2
%===============================================================================

%===============================================================================
% Start of Chapter 3
%===============================================================================
\chapter{The cost table approach}
The first approach that came into our mind was to pre-compute an $N \times L$ two dimensional table containing the number of crushing needed for $N$ number of iPads and $L$ strength levels in the worst-case scenario. When the player choose a certain strength level, we will look up the costs for the upper sub-problem and the lower sub-problem in the table, before comparing them to decide whether the iPad should break at that strength level or not.

\section{Detailed description}
Let us define the cost of a game state $(N, L)$ to be the minimum number of crushing using $N$ number of iPads and for $L$ strength levels. \\\\
In a game level with $N$ number of iPads and $L$ strength levels, the player chooses to crush at strength level $x$:
\begin{itemize}
\item if the iPad breaks, the game state becomes $N - 1$ number of iPads and $x - 1$ strength levels.
\item if the iPad does not break, the game state becomes $N$ number of iPads and $L - x$ strength levels.
\end{itemize}
We can compute the cost of $(N, L)$ by recursively computing all possible sub-problems, then pick the sub-problem with the minimum cost and add 1 to it. The final cost of $(N, L)$ would be $(1 + \text{cost of the minimum-cost sub-problem})$. Here are some base cases:
\begin{itemize}
\item if $N = 1$, the cost would be $L$ because the only way to find the correct strength is to try one by one from the lowest strength level to the highest strength level. In the worst-case, the iPad only breaks at the highest strength level, so it will need $L$ number of crushing.
\item if $L = 1$, the cost will be 1 since there is only one strength level to be crushed at.
\end{itemize}
Let $C(N, L)$ denote the cost for $N$ iPads and $L$ strength levels. \\
The recurrence is
\[
C(N, L) = 
\begin{cases}
L & \text{if $N = 1$} \\
1 & \text{if $L = 1$} \\
1 + min_{x \in [1, L]}(max(C(N - 1, x - 1), C(N, L - x))) & \text{otherwise}
\end{cases}
\]
So all we need is to compute a $N \times L$ two dimensional cost table for each possible combination of $N$ and $L$. For the game logic, if the player chooses to crush at strength level $x$, we will look up 
\begin{itemize}
\item $C(N - 1, x - 1)$ (cost of the remaining sub-problem if the iPad breaks)
\item $C(N, L - x)$ (cost of the remaining sub-problem if the iPad does not break)
\end{itemize}
in the cost table, if $C(N - 1, x - 1) > C(N, L - x)$, i.e. it will require more cost if the iPad breaks, then we will break the iPad. If $C(N - 1, x - 1) < C(N, L - x)$, i.e. it requires more cost if the iPad does not break, then we will not break the iPad. For cases when $C(N - 1, x - 1) = C(N, L - x)$, we can randomize the decision so that the game path will not always be the same.

\section{A brute force algorithm}
A naive way to implement this approach would be to compute every cell in the $N \times L$ cost table individually using the following algorithm:
\begin{algorithm}
\caption{$C(N, L)$}
\begin{algorithmic}[1]
\IF{$N = 1$}
	\RETURN $L$
\ELSIF{$L = 1$}
	\RETURN $1$
\ENDIF
\STATE $best \leftarrow \infty$
\FORALL{$k \in [1, L]$}
	\STATE $result = max(C(N - 1, x - 1), C(N, L - x))+1$
	\IF{$result < best$}
		\STATE $best \leftarrow result$
	\ENDIF
\ENDFOR
\RETURN $best$
\end{algorithmic}
\end{algorithm}
~\\
Clearly this algorithm runs in exponential time. In fact, computing the cost for a game state $(N, L)$ involves the computation of game states with lower $N$ or lower $L$. Therefore there is a lot of repeated computation here. In the next section we will talk about how to avoid such redundant computations.

\section{A dynamic programming algorithm}
Based on the naive brute-force algorithm, we have derived a dynamic programming algorithm which avoids the unnecessary repeated computations and makes computing the cost for large problems more practical. \\\\
As we mentioned in the last section, using the brute-force algorithm, the computation of a larger problem involves computing a number of smaller problems, therefore it exhibits the optimal substructure property. Moreover, different problems might need to compute the same sub-problems, therefore it exhibits the overlapping sub-problem property. Hence, we can speed up the computation of it by using dynamic programming. \\\\
Instead of computing each cell individually to fill the table, we initialize all the base cases first and then fill in the table row by row, making use of the already computed values to compute the new values. Here's the pseudo-code:
\begin{algorithm}
\caption{$makeTable(N, L)$}
\begin{algorithmic}[1]
\STATE $table \leftarrow 2DTable(N, L)$
\FOR{$i = 1$ \TO $N$}
	\STATE $table[i][1] = 1$
\ENDFOR
\FOR{$i = 1$ \TO $L$}
	\STATE $table[1][i] = i$
\ENDFOR
\FOR{$i = 2$ \TO $N$}
	\FOR{$j = 2$ \TO $L$}
		\STATE $best \leftarrow \infty$
		\FOR{$k = 2$ \TO $j$}
			\STATE $result = max(table[i - 1][k - 1], table[i][j - k])+1$
			\IF{$result < best$}
				\STATE $best \leftarrow result$
			\ENDIF
		\ENDFOR
		\STATE $table[i][j] = best$
	\ENDFOR
\ENDFOR
\end{algorithmic}
\end{algorithm}
~\\
Using the dynamic programming algorithm, we can reduce the running time of the algorithm to $O(NL^2)$. This is because for each of the $N \times L$ entries, we only need at most $L$ comparisons to get the result. \\\\
This allows us to compute the cost of up to hundreds of strength levels and tens of iPads, whereas the brute-force algorithm is only capable of computing problems up to around 20 strength levels and several iPads.
\section{Pros and Cons}
The good thing about this cost table approach is that it is simple and fast. Since it is an offline approach, we can pre-compute the cost table and store it in the game, so that during the game, we will be able to make decisions quickly by simply looking up the table and making some comparisons. \\\\
This approach also makes it easy for extensions, like adding either fixed cost or dynamic cost for breaking an iPad, which we will talk about in Chapter 5. \\\\
One disadvantage about this approach is that since we do not store the best strategies, there is no easy way for us to provide hints for the player. The only way we could provide hints will be to try every possible scenarios at that stage to compare and find the optimal one. We will discuss about an extension of this approach to support hints easily in the next chapter.

%===============================================================================
% End of Chapter 3
%===============================================================================

%===============================================================================
% Start of Chapter 4
%===============================================================================
\chapter{The optimum level approach}
Through the course of doing the project, Prof. Sim briefly mentioned about an approach that came naturally to him but was different from the cost table approach that every team in the class came up with. His approach was basically storing the optimum strength level to use in each cell of a $N$ by $L$ table. The optimum strength level is defined as the level of strength that the player should use such that he will require the least number of attempts to solve the game in the worst case scenario. When we need to decide if an iPad should be crushed given a strength level input, we look up the table and compare the given level input against the optimum input to make the decision. As this approach seemed different from our original approach, we have decided to look more into it to see if it is a viable solution, along with its advantages and disadvantages.

\section{Description of approach}
The idea behind the approach is simple. By knowing the optimum strength level to use at each stage of the game, we can simply decide whether to crush the iPad or not. If the player inputs a strength level that is lower than the optimum strength level, the iPad will not be crushed. If the input strength level is higher than the optimum level, the iPad will then be crushed.

\section{Viability of approach}
Following an extensive discussion we had about this particular approach, we came to realise that the approach will only give us the worst case scenario if it satisfies two conditions. Firstly, given a game state of $N$ iPads and $L$ strength levels $(N,L)$, there can be a number of different levels that are all optimal. Amongst these optimal strength levels, the largest level should be chosen as the optimum level. The second condition is that if the player decides to use the optimum strength level, then the game logic should make the decision to crush the iPad.

Let us explore the reasoning behind these two conditions using Figure 4.1 on the following page. Figure 4.1 shows us two optimal decision trees, each of height 7, that can be used to solve the game state $(2,30)$. The number in each node represents the strength level to use as a best strategy. If the iPad gets crushed, we will move down to the right subtree, and if the iPad is not crushed, then we move down the left subtree. With a height of 7, it means that at the very least, a player must make 8 attempts in order to win the game, and any situation that results in less will be because of a wrong decision made by the game logic.

The difference between these two trees is that tree \ref{fig:badtree} has 2 as its root node while tree \ref{fig:goodtree} has 8, which is the optimum level that corresponds to the trees. The strength levels 2 and 8 are also the smallest and largest values of all the possible values that give an optimal decision tree of height 7. 

With these two examples, imagine that we take 2 as the optimum level. In the event that the player wants to use a strength level of 3 to crush the iPad, the game logic will decide to crush the iPad, leaving the player with 1 iPad left and only 2 more levels to test. This means that the game can be solved using 3 attempts (continue testing level 1 and level 2 using the last iPad), which is not the worst case scenario. However, if we take 8 as the optimum level, when the player uses a strength of level 3, the game logic will decide not to crush the iPad, which is the correct decision to make as it results in a worse scenario compared to the decision to crush the iPad. 

\begin{figure}[H]
	\centering
	\begin{subfigure}{0.68\textwidth}
		\includegraphics[width=\textwidth]{DecisionTree1}
		\caption{Optimal tree with smallest value of optimum level}
		\label{fig:badtree}
	\end{subfigure}
	\begin{subfigure}{0.68\textwidth}
		\includegraphics[width=\textwidth]{DecisionTree2}
		\caption{Optimal tree with largest value of optimum level}
		\label{fig:goodtree}
	\end{subfigure}
	\caption{Optimal decision trees for 2 iPads and 30 strength levels}
	\label{fig:decisiontrees}
\end{figure}

Furthermore, if the player specifies a strength of level 9 to use, the game logic will make the correct decision to crush the iPad, as it will mean that the player has 1 iPad and 8 more levels to test, which is a trivial state that requires 8 attempts to complete. This gives a total of 9 attempts, which is worse than the best strategy that uses 8 attempts.

Now that we know we must choose 8 as our optimum level, what happens when the player chooses to use a strength level of 8? Should the game logic decide to crush the iPad or not? Will it make a difference? If we look at tree \ref{fig:goodtree}, we can quickly realise that if we make the game logic such that it does not crush the iPad, the player can follow down the decision tree and pick levels {8, 15, 20, 24, 27, 29, 30} subsequently to solve the game. This results in a total of 7 attempts, even though there is a longer path in our decision tree that needs 8 attempts. Therefore, by making the game logic such that it crushes when the optimum level is chosen, we can ensure that the player will always require at least $height + 1$ number of attempts to solve the game, which in this case will be 8.

There is an exception, however, and it happens when the player has only one iPad left. With only one iPad left, the player has to use the minimum strength that he is unsure of up to that point of the game, and slowly increase one level by one level until he reaches the maximum strength level he is unsure of. Since the optimum level in this case is the minimum strength level, if we follow the conditions above and crush the iPad when the player chooses this minimum level, the game will end earlier than expected. The player will know that minimum level - 1 is the highest strength level he can use. In order to maximise the number of attempts needed for the player to determine the highest strength level, we must ensure that the game logic checks if there is only 1 iPad left, and in that event, decides not to crush the iPad when the player chooses the minimum strength level. If the player does not choose the minimum strength level, then the iPad will be crushed and the player would have lost the game since he is left with zero iPad and has not solved the game.

\section{Implementation of approach}
After considering the viability of the approach, we went on to figure out how we would implement this approach. Since there was not a clear and direct link of how the optimum level of smaller problems can help to determine the optimum level of a bigger problem, further exploration was needed. 

After trying out some ways that included using the decision tree to fill a $N$ by $L$ table of optimum strength levels, we concluded that the more straightforward way is to simply keep both the cost (height of optimum tree) and the optimum level for each cell in the table. This would mean that the way we are implementing this approach is to extend upon our original solution, where instead of just storing the cost in each cell, we will also store the largest level that gives us this minimum cost. This will allow us to populate the table easily, by using the same way we did in Chapter 3.

\section{Advantages and disadvantages}
If the implementation of this approach is just an extension of our original solution, what are the advantages of storing the optimum level in each cell of our table? Are there any disadvantages as well? 

As mentioned by Prof. Sim, the advantage of knowing the optimum level of every game state will allow us to give the player hints of which strength level he should use. An example of a hint can be in the form of mathematical equations to be solved to indicate a range of values that includes the optimum level. This can provide a "side-game" for players and make the game more interesting, increasing the overall entertainment the game provides. 

There are some minor disadvantages though, and they include the conditions that were described earlier in this chapter. In order for the game logic to always output the worst case scenario for the player, we must take note of those conditions and be mindful when implementing the actual game logic.

%===============================================================================
% End of Chapter 4
%===============================================================================

%===============================================================================
% Start of Chapter 5
%===============================================================================
\chapter{Interesting extensions}
\section{iPad with fixed cost}

What happens if we have to pay a penalty for each crushed iPad. How would it affect the optimal strategy and the game logic?

\subsection{Optimal strategy with fixed cost iPad}

To determine how having a fixed cost for each crushed iPad affect the optimal strategy, we draw out the optimal decision tree for different amount of fixed iPad cost.

In particular, we observe how the optimal decision tree for when N = 2, L =20 changes as the cost increase from 0 to 5.

\begin{figure}[H]
	\begin{subfigure}{0.3\textwidth}
		\includegraphics[width=\textwidth]{fixed_cost_0}
		\caption{iPad Cost = 0}
		\label{fig:fixed_cost_0}
	\end{subfigure}
	\begin{subfigure}{0.3\textwidth}
		\includegraphics[width=\textwidth]{fixed_cost_1}
		\caption{iPad Cost = 1}
		\label{fig:fixed_cost_1}
	\end{subfigure}
	\begin{subfigure}{0.3\textwidth}
		\includegraphics[width=\textwidth]{fixed_cost_2}
		\caption{iPad Cost = 2}
		\label{fig:fixed_cost_2}
	\end{subfigure}
	\begin{subfigure}{0.3\textwidth}
		\includegraphics[width=\textwidth]{fixed_cost_3}
		\caption{iPad Cost = 3}
		\label{fig:fixed_cost_3}
	\end{subfigure}
	\begin{subfigure}{0.3\textwidth}
		\includegraphics[width=\textwidth]{fixed_cost_4}
		\caption{iPad Cost = 4}
		\label{fig:fixed_cost_4}
	\end{subfigure}
	\begin{subfigure}{0.3\textwidth}
		\includegraphics[width=\textwidth]{fixed_cost_5}
		\caption{iPad Cost = 5}
		\label{fig:fixed_cost_5}
	\end{subfigure}
	\caption{Optimal Decision Trees for Ipad Cost from 0 to 5 for 2 iPads and 20 strength levels}
	\label{fixed_cost_tree}
\end{figure}

It can be observed from Figure ~\ref{fixed_cost_tree} that there is strong bias for the optimal tree to branch into the not-crushed direction as the iPad cost increases. This also means that as the fixed cost of the iPad increases it takes a lot more trials of dropping the iPad without it being crushed to be as expensive as a single trial of dropping and crushing an iPad. 

\subsection{Game logic with fixed cost iPad}

To tackle the extension, we realise we can re-use our cost table approach, but modify the comparison step slightly to also include the fixed cost. 

Using the table cost approach, we would calculate the cost of the whole cost table during the game initialisation, and subsequently use the value already calculated in the table cell to make the game decisions

In this extension, we consider two scenarios: The number of iPads is finite or infinite

In the case that there is a finite number of iPads, the cost table will be a 2D array, where the number of rows represent the number of remaining iPads, and the number of columns represents the number of remaining strength levels

The pseudo code to calculate the cost table for finite number of iPads is as follows

\begin{algorithm}[H]
\caption{Calculate the cost table for fixed iPad cost (finite number of iPads}
\begin{algorithmic}[1]
\REQUIRE N, L, iPadCost
\FOR{$i = 1$ \TO $N$}
	\STATE $table[i][1] = 1+iPadCost$
\ENDFOR
\FOR{$i = 1$ \TO $L$}
	\STATE $table[1][i] = i+iPadCost$
\ENDFOR
\FOR{$i = 2$ \TO $N$}
	\FOR{$j = 2$ \TO $L$}
		\STATE $best \leftarrow \infty$
		\FOR{$k = 1$ \TO $j$}
			\STATE $result = max(table[i - 1][k - 1]+iPadCost, table[i][j - k]) + 1$
			\IF{$result < best$}
				\STATE $best \leftarrow result$
			\ENDIF
		\ENDFOR
		\STATE $table[i][j] = best$
	\ENDFOR
\ENDFOR
\end{algorithmic}
\end{algorithm}

We can see that the difference between this and the previous cost table approach without iPad cost is only that the iPad cost is also added to the original cost in each cell

In the case that there is an infinite number of iPads, the cost table only needs to be a 1D array. Since the number of iPads is infinite, we no longer need to worry that we might run out of iPads. As such, we only need to consider how the cost will vary by the number of remaining strength levels. The number of cells in the cost table hence represents the number of remaining strength levels

The pseudo code to calculate the cost table for infinite number of iPads is as follows

\begin{algorithm}[H]
\caption{Calculate the cost table for fixed iPad cost (infinite number of iPads)}
\begin{algorithmic}[1]
\REQUIRE L, iPadCost
\STATE $table \leftarrow 1DTable(L)$
\STATE $table[1] = iPadCost+1$
\FOR{$i = 2$ \TO $L$}
	\STATE $best \leftarrow \infty$
	\FOR{$k = 1$ \TO $j$}
		\STATE $result = max(table[k - 1] + iPadCost, table[j - k])$
		\IF{$result < best$}
			\STATE $best \leftarrow result$
		\ENDIF
	\ENDFOR
	\STATE $table[i] = best$
\ENDFOR
\end{algorithmic}
\end{algorithm}

\section{iPad with dynamic cost}

Let's make the problem even more complex. How do we tackle the problem if the cost of the iPad is not fixed, but changing depending on how many iPad has been crushed. 

We focus how the game logic would need to be adapted.

We can first define a function f, where f(n) denotes the cost of the $n^{th}$ having been crushed.
Intuitively, we can see that this problem is very close to the fixed iPad cost problem. We can again use the cost table approach to pre-calculate the cost table. The difference lies in the fact that we also now need to consider how many iPads have been crushed before.

We again consider the two scenarios where there are finite and infinite number of iPads.

It turns out we can adapt the algorithm used to calculate the cost table for fixed cost iPads to calculate the cost table for dynamic cost iPads. Recall that the value in a particular cell in the cost table table[i][j] represents the cost when there are i remaining iPads and j remaining strength levels. It can be observed then that if a particular game starts with N iPads, the number of iPads that have been crushed at a cell is N-i. So the cost of crushing the next iPad would be f(N-i+1)

Following that intuition, we can come up with the pseudo code to calculate the cost table for finite number of iPads as follows

\begin{algorithm}[H]
\caption{Calculate the cost table for dynamic iPad cost (finite number of iPads)}
\begin{algorithmic}[1]
\REQUIRE N, L, f
\STATE $table \leftarrow 2DTable(N, L)$
\FOR{$i = 1$ \TO $N$}
	\STATE $table[i][1] = 1 + f(N-i+1)$
\ENDFOR
\FOR{$i = 1$ \TO $L$}
	\STATE $table[1][i] = i + f(N)$
\ENDFOR
\FOR{$i = 2$ \TO $N$}
	\FOR{$j = 2$ \TO $L$}
		\STATE $best \leftarrow \infty$
		\FOR{$k = 1$ \TO $j$}
			\STATE $result = max(table[i - 1][k - 1] + f(N-i+1), table[i][j - k]) + 1$
			\IF{$result < best$}
				\STATE $best \leftarrow result$
			\ENDIF
		\ENDFOR
		\STATE $table[i][j] = best$
	\ENDFOR
\ENDFOR
\end{algorithmic}
\end{algorithm}

The limitation to calculating the cost table in this way is that this cost table can only apply for a particular game instance with a fixed starting number of iPads N. This is perhaps less flexible than the cost table that is calculated for fixed cost iPads which can be used for multiple game instances with multiple starting number of iPads.

A possible way to overcome this limitation is possibly to make the cost table 3D, with the extra dimension representing different starting number of iPads.

For infinite number of iPads, however, the cost table method breaks down. As the starting number of iPads is indeterminate, it is impossible to precompute the cost table for all possible game states.


%===============================================================================
% End of Chapter 5
%===============================================================================

%===============================================================================
% Start of Chapter 6
%===============================================================================


\chapter{The online combinatorics approach}
Besides the Dynamic Programming approach to this iPad Crushing problem, we also found an interesting alternative approach online using Combinatorics to calculate how many times we need to crush the iPad in the worst case \cite{randomblogpost}. The original author describes it as a solution to the classic Egg Dropping Puzzle. Here, we formulate the solution in terms of our iPad Crushing problem and make some corrections.

\section{Theory}
Before we begin discussing the solution, we need to reiterate our definition of a strategy to solve the iPad Crushing problem. A strategy is a binary decision tree, with each node representing a level of strength that we will use to try crushing the iPad. Following the left branch represents the scenario that the iPad survives the crush, while the right branch represents the scenario when the iPad does not survive the crush. A leaf of the tree represents the minimum level of strength to crush the iPad that we have found. Figure \ref{fig:comb-original} illustrates a decision tree when there are 3 iPads and 10 strength levels.

\begin{figure}
	\centering
	\begin{subfigure}{1.0\textwidth}
		\includegraphics[width=\textwidth]{comb-original}
		\caption{Decision tree of the optimal strategy with 3 iPads and 10 strength levels}
		\label{fig:comb-original}
	\end{subfigure}
	\begin{subfigure}{1.0\textwidth}
		\includegraphics[width=\textwidth]{comb-binary-sequence}
		\caption{How the decision tree is converted to binary sequences}
		\label{fig:comb-binary-sequence}
	\end{subfigure}
	\caption{Example of a decision tree and its conversion to binary sequences}
\end{figure}

The number of crushings we need to do to determine the minimum strength level to crush the iPad is the length of a path from the root node to a leaf. Hence, the number of crushings in the worst case is just the height of the decision tree. The goal of the game is to find a decision tree with minimum height.

Similar to the dynamic programming approach, given the number of levels $L$ and the number of iPads $N$, we will need to find the minimum height $H$ of a decision tree to solve this iPad Crushing Problem. However, we will do this by formulating a slightly different problem. This is quite similar to the proof that all comparison-based sorting algorithms need to make at least $\log n$ comparisons in the worst case. An iPad Crushing problem with $N$ iPads and $L$ strength levels has a decision tree of height $H$. We will find the maximum $L$, given $N$ and $H$.

We will count the number of possible leaves in the decision tree of height $H$. We note that every path from the root node to a leaf can branch to the right (the iPad does not survive) at most $N$ times. Hence each leaf can be represented by a binary sequence of 1 (left) and 0 (right), with at most $N$ zeros (rights). Since the height of our decision tree is $H$, the length of each binary sequence is at most $H$. For a binary sequence with length less than $H$, we can append it with ones until the length becomes $H$. Figure \ref{fig:comb-binary-sequence} illustrates this process. Note that this is a one-to-one transformation because there are no 2 leaves in the same tree such that the first leaf's binary sequence starts with the same digits as the second leaf's binary sequence (e.g. if there is a leaf 010, there cannot be any leaf that starts with 010, hence there will not be any duplication when we append 010 with 1's). Due to this injectivity, the number of leaves possible is at most the number of binary sequences of length $H$ with at most $N$ zeros. There are ${H \choose k}$ binary sequences of length $H$ with $k$ zeros. Therefore, the maximum number of leaves in a decision tree of height $H$ is $\sum_{k=0}^{N} {H \choose k}$.

Obviously, the number of  leaves is exactly $L+1$, as there are $L+1$ possible values for the minimum strength level to crush the iPad. Thus, we arrive at the inequality: \[\sum_{k=0}^{N} {H \choose k} \geq L+1\]

Going back to our original problem, the decision tree for this iPad Crushing problem with $N$ iPads and $L$ strength levels will have the minimum height $H$ such that the above inequality holds.

\section{Algorithm}
Based on the theory discussed in the previous section, together with the fact that $H \geq \log L$ since the decision tree is a binary tree, we formulate the following algorithm to calculate the cost in the worst case of the iPad Crushing problem.

\begin{algorithm}
        \caption{Calculate the cost of the iPad Crushing problem with N iPads, L strength levels}
        \begin{algorithmic}[1]
            \REQUIRE N, L
	\STATE $H \leftarrow \lceil \log L\rceil$
	\STATE $sum \leftarrow \sum_{k=0}^{N} {H \choose k}$
	\WHILE {$sum < L+1$}
		\STATE $H \leftarrow H+1$
		\STATE $sum \leftarrow \sum_{k=0}^{N} {H \choose k}$
	\ENDWHILE
	\RETURN $H$
        \end{algorithmic}
\end{algorithm}

\section{Discussion}
We can use the algorithm outlined in the previous section to fill in our $N \times L$ cost table. The running time of this algorithm is dependent on the size of the answer it gets, i.e. $H$, as well as on how fast combination can be calculated. If we assume that ${H \choose k}$ can be computed in $O(H)$ time, then the time to compute one entry in the cost table is $O(NH^2)$. For the dynamic programming approach, the time to compute one entry in the cost table is $O(L)$. We do not have the necessary mathematical tools to rigorously compare those 2 time complexities; however, according to our test, filling the cost table with this approach takes roughly the same time as the dynamic programming approach.

Nevertheless, the advantage of this approach is that it can compute the cost of the iPad Crushing problem, given $N$ and $L$, very fast. That is because it does not need to calculate the cost of any smaller problems like the dynamic programming approach.  As an example, our implementation of the combinatoric calculates the cost in the worst case with 1 million levels, 10 iPads instantly, while the dynamic programming approach takes so long that we terminate it before it returns a result. Hence, we do not have to pre-calculate the cost table like the dynamic programming approach. When the player decides to crush the iPad at level $l$, we can just calculate and compare the cost if the iPad is crushed and if it is not crushed and choose the scenario with the higher cost directly.

At first, we thought that the downside of this approach would be its inflexibility, i.e. it is harder to tweak to solve modified versions of the iPad Crushing problem. However, we actually manage to tweak it to solve the modified versions as well.

To solve the problem when the cost of an iPad is a constant $c$, we need replace each branch to the right with $(c+1)$ consecutive branchings to the right. Hence the total number of possible paths will be the number of binary sequences of length $H$ such that zeros can only appear in group of $(c+1)$, and there are at most $N$ groups of $(c+1)$ zeros. To solve this, we need to consider a group of $(c+1)$ zeros as one units (one 0), which decreases the length of the sequence to $H - c \times number\_of\_groups$. This gives us a more complicated inequality, but can still be substituted into the proposed algorithm to solve the question: \[\sum_{k=0}^{N} {H-ck \choose k} \geq L+1\]

Even when there are inifinitely many available iPad for use, the inequality can be modified to solve the problem. Instead of summing until $N$, we can sum until ${H-ck \choose k}$ still makes sense, that is until $\lfloor H/c \rfloor$. This gives us the inequality: \[\sum_{k=0}^{\lfloor H/c \rfloor} {H-ck \choose k} \geq L+1\]

A modification can also be made to solve the problem with dynamic iPad cost. Let $f(x)$ be the function that return the cost of the $x^{th}$ iPad crushed. We define the function $S(x)$ as the sum of the cost of the 1st $x$ iPads crushed, i.e.: \[S(x) = \sum_{i=0}^x f(i)\] The core inequality essential to the combinatoric method will then become: \[\sum_{k=0}^N {H-S(k) \choose k} \geq L+1\] If there are infinitely many iPads available, the inequality becomes: \[\sum_{\substack{k \in \mathbb{Z}_{\geq 0}\\ S(k) < H}} {H-S(k) \choose k} \geq L+1\] Using this inequality and the algorithm outlined in the previous section, we can compute the cost in the worst case scenario on the fly. Hence we can decide, given a level l that the player wants to crush the iPad at and the number of iPads that have been crushed, whether making the iPad survive or crushed will be the worse scenario. This is an advantage compared to the dynamic programming approach, which cannot compute all the possible game states before hand (because there are infinitely many game states) and its running time is slow when computing on the fly.

%===============================================================================
% End of Chapter 6
%===============================================================================

%===============================================================================
% Start of Chapter 7
%===============================================================================
\chapter{Conclusion}
We have presented 3 different approaches, namely the cost table approach, the optimum level approach, and the combinatorics approach. We discussed the design of the game logic using each approach, how they work, their implementations, their advantages and disadvantages. We also talked about how we can extend our approaches to support several extensions of the game. \\\\
The cost table is simple and fast, easy to understand and extensible. It is good for designing the game logic but not very suitable for giving hints. In contrast, the optimum level approach would be better for giving hints. Thus, it can be a good idea to combine them so that we can design game logics for different extensions of the game and yet still be able to provide hints. \\\\
The combinatorics method is a interesting method to compute the cost table but not as straightforward as the dynamic programming method. Even though this approach can be fast when computing certain huge problems, it might not be as fast as the dynamic programming algorithm when it comes to populating the table. \\\\
Through this project, we have gained a lot of new knowledge and insights from the solutions we presented. More importantly, the experiences gained from this project will definitely be useful for us in doing future research.

%===============================================================================
% End of Chapter 7
%===============================================================================

%===============================================================================
% Start of References
%===============================================================================
\renewcommand{\bibname}{References}
\begin{thebibliography}{1} \addcontentsline{toc}{chapter}{References}
	\bibitem{dpwiki} Dynamic Programming. https://en.wikipedia.org/wiki/Dynamic\_programming
	\bibitem{randomblogpost} Egg Drop Puzzle. http://michaelbrundage.com/note/2014/04/26/egg-drop/
\end{thebibliography}

%===============================================================================
% End of References
%===============================================================================
\end{document}
